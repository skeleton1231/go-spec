# Go编程语言规范
### 2022年12月15日版本

## 介绍

这是Go编程语言的参考手册。没有泛型的pre-Go1.18版本可以在此处找到。有关更多信息和其他文档，请查看golang.org。

Go是一种通用语言，专为系统编程而设计。它是强类型的、垃圾收集的，并对并发编程有明确的支持。程序是由包构建的，其属性允许有效管理依赖关系。

语法紧凑，易于解析，允许集成开发环境等自动工具进行轻松分析。

## 符号记法

语法是使用扩展巴科斯-诺尔形式（EBNF）的变体指定的：

```
Syntax = { Production } .
Production = production_name "=" [ Expression ] "." .
Expression = Term { "|" Term } .
Term = Factor { Factor } .
Factor = production_name | token [ "…" token ] | Group | Option | Repetition .
Group = "(" Expression ")" .
Option = "[" Expression "]" .
Repetition = "{" Expression "}" .
```

产生式是从术语和以下运算符构建的表达式，优先级逐渐提高：

```
| 交替
() 组合
[] 选项（0或1次）
{} 重复（0至n次）
```

小写的产生式名称用于识别词汇（终端）记号。非终端以驼峰形式表示。词汇记号用双引号""或反引号``包围。

形式a … b表示从a到b的字符集作为替代。水平省略号…也在规范的其他地方用于非正式地表示各种未进一步指定的枚举或代码片段。字符…（而不是三个字符...）并非Go语言的记号。

## 源代码表示

源代码是以UTF-8编码的Unicode文本。文本没有规范化，所以一个带有重音的代码点与由重音和字母组合构成的同一个字符不同；它们被视为两个代码点。为了简单起见，本文档将使用“字符”一词来指代源文本中的Unicode代码点。

每个代码点都是不同的；例如，大写字母和小写字母是不同的字符。

实现限制：为了与其他工具兼容，编译器可能不允许在源文本中使用NUL字符（U+0000）。

实现限制：为了与其他工具兼容，如果UTF-8编码的字节顺序标记（U+FEFF）是源文本中的第一个Unicode代码点，编译器可能会忽略它。在源代码的其他地方可能不允许使用字节顺序标记。

### 字符
以下术语用于表示特定的Unicode字符类别：
```
newline        = /* Unicode代码点U+000A */ .
unicode_char   = /* 除换行符之外的任意Unicode代码点 */ .
unicode_letter = /* 被分类为"Letter"的Unicode代码点 */ .
unicode_digit  = /* 被分类为"Number, decimal digit"的Unicode代码点 */ .
```
在Unicode标准8.0中，第4.5节"General Category"定义了一组字符类别。Go将所有在任何Letter类别Lu、Ll、Lt、Lm或Lo中的字符视为Unicode字母，将Number类别Nd中的字符视为Unicode数字。

字母和数字
下划线字符_（U+005F）被视为小写字母。
```
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
binary_digit  = "0" | "1" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
```

### 词法元素
评论
注释用作程序文档。有两种形式：

- 行注释以字符序列 // 开始，并在行尾停止。
- 一般注释以字符序列 /* 开始，并在随后的第一个字符序列 */ 处停止。
  
注释不能在符文或字符串文字内部或注释内部开始。不包含换行符的一般注释的作用类似于空格。任何其他注释的作用就像换行符一样。

### 令牌
令牌构成了Go语言的词汇。有四个类别：标识符、关键字、运算符和标点符号以及文字。空白（由空格（U+0020）、水平制表符（U+0009）、回车（U+000D）和换行符（U+000A）形成）被忽略，除非它分隔了本来会合并成单个令牌的令牌。此外，换行符或文件结尾可能会触发分号的插入。在将输入内容分解为令牌时，下一个令牌是构成有效令牌的字符的最长序列。

## 分号
正式语法在许多产生式中使用分号“;”作为终结符。Go程序可以使用以下两条规则省略大多数这些分号：

- 当输入被分解为令牌时，如果该行的最后一个令牌是以下之一，则分号会自动插入到令牌流中：
  - 一个标识符
  - 一个整数、浮点数、虚数、符文或字符串文字
  - 关键字之一 break、continue、fallthrough 或 return
  - 运算符和标点符号 ++、--、)、] 或 } 之一
- 为了允许复杂的语句占用一行，可以省略")"或"}"之前的分号。

为了反映习惯用法，本文档中的代码示例使用这些规则省略了分号。

## 标识符
标识符命名程序实体，如变量和类型。标识符是一个或多个字母和数字的序列。标识符中的第一个字符必须是字母。

```
identifier = letter { letter | unicode_digit } .
a
_x9
ThisVariableIsExported
αβ
```

有些标识符是预声明的。

## 关键字
以下关键字是保留的，不能用作标识符。

```
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

运算符和标点符号
以下字符序列表示运算符（包括赋值运算符）和标点符号：

```
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=          ~
```

### 整数字面量
整数字面量是代表整数常数的数字序列。可选的前缀设定了一个非十进制基数：0b 或 0B 表示二进制，0、0o 或 0O 表示八进制，0x 或 0X 表示十六进制。单个0被视为十进制零。在十六进制字面量中，字母a到f和A到F表示10到15的值。

为了便于阅读，在基数前缀后或连续数字之间可以出现下划线字符 _；这样的下划线不会改变字面量的值。

```
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .
decimal_lit    = "0" | ( "1" … "9" ) [ [ "_" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .

decimal_digits = decimal_digit { [ "_" ] decimal_digit } .
binary_digits  = binary_digit { [ "_" ] binary_digit } .
octal_digits   = octal_digit { [ "_" ] octal_digit } .
hex_digits     = hex_digit { [ "_" ] hex_digit } .
```

例子：
```
42
4_2
0600
0_600
0o600
0O600       // 第二个字符是大写字母'O'
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727
```

不合规的例子：
```
_42         // 一个标识符，不是整数字面量
42_         // 无效：_ 必须分隔连续的数字
4__2        // 无效：一次只能有一个 _
0_xBadFace  // 无效：_ 必须分隔连续的数字
```

### 浮点字面量
浮点字面量是浮点常数的十进制或十六进制表示。

十进制浮点字面量由整数部分（十进制数字）、小数点、分数部分（十进制数字）和指数部分（e 或 E 后跟可选的符号和十进制数字）组成。整数部分或分数部分可以省略其中之一；小数点或指数部分也可以省略其中之一。指数值 exp 通过 10exp 缩放尾数（整数和分数部分）。

十六进制浮点字面量由 0x 或 0X 前缀、整数部分（十六进制数字）、基数点、分数部分（十六进制数字）和指数部分（p 或 P 后跟可选的符号和十进制数字）组成。整数部分或分数部分可以省略其中之一；基数点也可以省略，但指数部分是必需的。（此语法与 IEEE 754-2008 第5.12.3节中给出的语法相匹配。）指数值 exp 通过 2exp 缩放尾数（整数和分数部分）。

为了便于阅读，在基数前缀后或连续数字之间可以出现下划线字符 _；这样的下划线不会改变字面值。

```
float_lit         = decimal_float_lit | hex_float_lit .

decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                    decimal_digits decimal_exponent |
                    "." decimal_digits [ decimal_exponent ] .
decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .

hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
hex_mantissa      = [ "_" ] hex_digits "." [ hex_digits ] |
                    [ "_" ] hex_digits |
                    "." hex_digits .
hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .
```

例子：
```
0.
72.40
072.40       // 等于 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // 等于 15.0
0.15e+0_2    // 等于 15.0

0x1p-2       // 等于 0.25
0x2.p10      // 等于 2048.0
0x1.Fp+0     // 等于 1.9375
0X.8p-0      // 等于 0.5
0X_1FFFP-16  // 等于 0.1249847412109375
0x15e-2      // 等于 0x15e - 2（整数减法）
```

不合规的例子：
```
0x.p1        // 无效：尾数没有数字
1p-2         // 无效：p 指数需要十六进制尾数
0x1.5e-2     // 无效：十六进制尾数需要 p 指数
1_.5         // 无效：_ 必须分隔连续的数字
1._5         // 无效：_ 必须分隔连续的数字
1.5_e1       // 无效：_ 必须分隔连续的数字
1.5e_1       // 无效：_ 必须分隔连续的数字
1.5e1_       // 无效：_ 必须分隔连续的数字
```

### 虚数字面量

虚数字面量表示复数常数的虚部。它由一个整数或浮点数字面量后跟小写字母i组成。虚数字面量的值是相应的整数或浮点数字面量的值乘以虚数单位i。

```
imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .
```

为了向后兼容，虚数字面量的整数部分完全由十进制数字（可能还有下划线）组成，即使以前导0开头，也被视为十进制整数。

```
0i
0123i         // 为了向后兼容，等于 123i
0o123i        // 等于 0o123 * 1i == 83i
0xabci        // 等于 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // 等于 0x1p-2 * 1i == 0.25i
```
### Rune 字面量

Rune 字面量表示 rune 常量，即标识 Unicode 代码点的整数值。Rune 字面量表现为单引号中的一个或多个字符，例如 'x' 或 '\n'。在引号内，除了换行符和未转义的单引号外，任何字符都可能出现。单个引号内的字符表示字符本身的 Unicode 值，而以反斜杠开头的多字符序列以各种格式编码值。

最简单的形式表示引号内的单个字符；由于 Go 源文本是以 UTF-8 编码的 Unicode 字符，因此多个 UTF-8 编码的字节可能表示一个整数值。例如，字面量 'a' 包含一个字节，表示字面上的 a，Unicode U+0061，值为 0x61，而 'ä' 包含两个字节（0xc3 0xa4）表示字面上的 a-重音符号，U+00E4，值为 0xe4。

几种反斜杠转义允许将任意值编码为 ASCII 文本。有四种方式可以将整数值表示为数字常量：\x 后面紧跟两个十六进制数字；\u 后面紧跟四个十六进制数字；\U 后面紧跟八个十六进制数字；以及普通的反斜杠 \ 后面紧跟三个八进制数字。在每种情况下，字面量的值都是相应基数的数字所代表的值。

尽管这些表示形式都会得到一个整数，但它们具有不同的有效范围。八进制转义必须代表0到255（含）之间的值。十六进制转义通过构造满足此条件。\u 和 \U 代表 Unicode 代码点，因此在它们内部某些值是非法的，特别是那些高于 0x10FFFF 和代理半部分的值。

在反斜杠后面，某些单字符转义代表特殊值：

```
\a   U+0007 警报或铃声
\b   U+0008 退格键
\f   U+000C 换页符
\n   U+000A 换行符或新行
\r   U+000D 回车
\t   U+0009 水平制表符
\v   U+000B 垂直制表符
\\   U+005C 反斜杠
\'   U+0027 单引号（仅在 rune 字面量中有效的转义）
\"   U+0022 双引号（仅在字符串字面量中有效的转义）
```

在 rune 字面量中，反斜杠后的无法识别字符是非法的。

```
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
```

```
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // 包含单引号字符的 rune 字面量
'aa'         // 非法：字符太多
'\k'         // 非法：反斜杠后不识别 k
'\xa'        // 非法：十六进制数字太少
'\0'         // 非法：八进制数字太少
'\400'       // 非法：八进制值超过 255
'\uDFFF'     // 非法：代理半部分
'\U00110000' // 非法：无效的 Unicode 代码点
```
### 字符串字面量

字符串字面量表示从连接一系列字符获得的字符串常量。有两种形式：原始字符串字面量和解释字符串字面量。

原始字符串字面量是反引号之间的字符序列，如 `foo`。在引号内，除了反引号外，可以出现任何字符。原始字符串字面量的值是引号之间未解释的（隐式 UTF-8 编码的）字符组成的字符串；特别地，反斜杠没有特殊意义，字符串可能包含换行符。原始字符串字面量中的回车字符（'\r'）会从原始字符串值中丢弃。

解释字符串字面量是双引号之间的字符序列，如 "bar"。在引号内，可以出现除换行符和未转义的双引号外的任何字符。引号之间的文本形成了字面量的值，反斜杠转义符被解释，就像在 rune 字面量中一样（除了 \' 是非法的，而 \" 是合法的），具有相同的限制。三位八进制（\nnn）和两位十六进制（\xnn）转义表示结果字符串的单个字节；所有其他转义表示单个字符的（可能是多字节的）UTF-8 编码。因此，在字符串字面量内，\377 和 \xFF 表示值为 0xFF=255 的单个字节，而 ÿ、\u00FF、\U000000FF 和 \xc3\xbf 表示字符 U+00FF 的 UTF-8 编码的两个字节 0xc3 0xbf。

```
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
```

```
`abc`                // 与 "abc" 相同
`\n
\n`                  // 与 "\\n\n\\n" 相同
"\n"
"\""                 // 与 `"` 相同
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // 非法：代理半部分
"\U00110000"         // 非法：无效的 Unicode 代码点
```

这些例子都代表同一个字符串：

```
"日本語"                                 // UTF-8 输入文本
`日本語`                                 // 作为原始字面量的 UTF-8 输入文本
"\u65e5\u672c\u8a9e"                    // 明确的 Unicode 代码点
"\U000065e5\U0000672c\U00008a9e"        // 明确的 Unicode 代码点
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 明确的 UTF-8 字节
```

如果源代码将一个字符表示为两个代码点，例如涉及重音符号和字母的组合形式，那么如果放在 rune 字面量中，结果将是一个错误（它不是单个代码点），如果放在字符串字面量中，它将显示为两个代码点。

### 常量

存在布尔常量、符文常量、整数常量、浮点常量、复数常量和字符串常量。符文、整数、浮点和复数常量统称为数值常量。

常量值由符文、整数、浮点、虚数或字符串字面量、表示常量的标识符、常量表达式、结果为常量的转换或某些内置函数的结果值表示，例如应用于常量参数的 min 或 max，应用于某些值的 unsafe.Sizeof，应用于某些表达式的 cap 或 len，应用于复数常量的 real 和 imag 以及应用于数值常量的 complex。布尔真值由预声明的常量 true 和 false 表示。预声明的标识符 iota 表示一个整数常量。

通常，复数常量是常量表达式的一种形式，并在该部分中讨论。

数值常量代表任意精度的确切值，不会溢出。因此，没有代表 IEEE-754 负零、无穷大和非数值的常量。

常量可以是有类型的或无类型的。字面常量、true、false、iota 和只包含无类型常量操作数的某些常量表达式是无类型的。

常量可以通过常量声明或转换显式地给出类型，或在用于变量声明或赋值语句或作为表达式中的操作数时隐式地给出类型。如果常量值不能表示为相应类型的值，则为错误。如果类型是类型参数，则常量被转换为类型参数的非常量值。

无类型常量具有默认类型，该类型是在需要类型值的上下文中隐式转换为该常量的类型，例如，在没有显式类型的短变量声明中，如 i := 0。无类型常量的默认类型分别是 bool、rune、int、float64、complex128 或 string，具体取决于它是布尔、符文、整数、浮点、复数还是字符串常量。

实现限制：尽管语言中的数值常量具有任意精度，但编译器可能使用有限精度的内部表示来实现它们。也就是说，每个实现必须：

- 用至少256位表示整数常量。
- 用至少256位的尾数和至少16位的有符号二进制指数表示浮点常量，包括复数常量的部分。
- 如果无法精确表示整数常量，则给出错误。
- 如果由于溢出而无法表示浮点或复数常量，则给出错误。
- 如果由于精度限制而无法表示浮点或复数常量，则四舍五入为最接近的可表示常量。

这些要求适用于字面常量和评估常量表达式的结果。

### 变量
变量是用于存储值的存储位置。允许的值集由变量的类型决定。

变量声明或者对于函数参数和结果，函数声明或函数字面量的签名为命名变量保留存储空间。调用内置函数 new 或获取复合字面量的地址在运行时为变量分配存储空间。这种匿名变量通过（可能是隐式的）指针间接引用来引用。

数组、切片和结构类型的结构化变量具有可以单独寻址的元素和字段。每个这样的元素都像一个变量一样运作。

变量的静态类型（或仅仅是类型）是在其声明中给出的类型、new 调用或复合字面量中提供的类型，或结构化变量的元素的类型。接口类型的变量还具有不同的动态类型，这是在运行时分配给变量的值的（非接口）类型（除非该值是预声明的标识符 nil，它没有类型）。动态类型可能在执行期间变化，但存储在接口变量中的值始终可以分配给变量的静态类型。

go
Copy code
var x interface{}  // x 为 nil 并且具有静态类型 interface{}
var v *T           // v 的值为 nil，静态类型为 *T
x = 42             // x 的值为 42，动态类型为 int
x = v              // x 的值为 (*T)(nil)，动态类型为 *T
通过在表达式中引用变量来检索变量的值；它是分配给变量的最新值。如果变量尚未被分配一个值，它的值是其类型的零值。