### 类型

类型决定了一组值以及针对这些值的特定操作和方法。类型可以由类型名表示（如果有的话），如果类型是泛型，则类型名后必须跟类型参数。类型也可以使用类型字面量来指定，该字面量从现有类型中组合出新类型。

```go
Type      = TypeName [ TypeArgs ] | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeArgs  = "[" TypeList [ "," ] "]" .
TypeList  = Type { "," Type } .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
            SliceType | MapType | ChannelType .
```

语言预声明了某些类型名。其他的则通过类型声明或类型参数列表引入。复合类型——数组、结构、指针、函数、接口、切片、映射和通道类型——可以使用类型字面量构造。

预声明的类型、定义的类型和类型参数称为命名类型。如果别名声明中给出的类型是命名类型，则别名表示一个命名类型。

#### 布尔类型

布尔类型代表由预声明的常量 true 和 false 表示的布尔真值集。预声明的布尔类型是 bool；它是一个定义的类型。

#### 数值类型

整数、浮点数或复数类型分别代表整数、浮点数或复数值的集合。它们统称为数值类型。预声明的与体系结构无关的数值类型有：

```go
uint8       所有无符号 8 位整数的集合（0 到 255）
uint16      所有无符号 16 位整数的集合（0 到 65535）
uint32      所有无符号 32 位整数的集合（0 到 4294967295）
uint64      所有无符号 64 位整数的集合（0 到 18446744073709551615）

int8        所有有符号 8 位整数的集合（-128 到 127）
int16       所有有符号 16 位整数的集合（-32768 到 32767）
int32       所有有符号 32 位整数的集合（-2147483648 到 2147483647）
int64       所有有符号 64 位整数的集合（-9223372036854775808 到 9223372036854775807）

float32     所有 IEEE-754 32位浮点数的集合
float64     所有 IEEE-754 64位浮点数的集合

complex64   具有 float32 实部和虚部的所有复数的集合
complex128  具有 float64 实部和虚部的所有复数的集合

byte        uint8 的别名
rune        int32 的别名
```

n 位整数的值宽度为 n 位，并使用二进制补码算术表示。

还有一组预声明的具有实现特定大小的整数类型：

```go
uint     32位或64位
int      与uint大小相同
uintptr  足够大以存储指针值的未解释位的无符号整数
```

为避免可移植性问题，所有数值类型都是定义的类型，因此除了 byte（是 uint8 的别名）和 rune（是 int32 的别名）之外都是不同的。当在表达式或赋值中混合不同的数值类型时，需要明确的转换。例如，即使 int32 和 int 在特定架构上可能具有相同的大小，它们也不是相同的类型。

#### 字符串类型

字符串类型代表字符串值的集合。字符串值是字节的（可能为空的）序列。字节数称为字符串的长度，永远不是负数。字符串是不可变的：一旦创建，就无法更改字符串的内容。预声明的字符串类型是 string；它是一个定义的类型。

可以使用内置函数 len 来发现字符串 s 的长度。如果字符串是常量，则长度是编译时常量。可以通过整数索引 0 到 len(s)-1 来访问字符串的字节。取这种元素的地址是非法的；如果 s[i] 是字符串的第 i 个字节，则 &s[i] 是无效的。

#### 数组类型

数组是单一类型元素的编号序列，称为元素类型。元素的数量称为数组的长度，永远不是负数。

```go
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
```

长度是数组类型的一部分；它必须计算为类型 int 可表示的非负常数。可以使用内置函数 len 来发现数组 a 的长度。元素可以通过整数索引 0 到 len(a)-1 来寻址。数组类型始终是一维的，但可以组成以形成多维类型。

```go
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // 与 [2]([2]([2]float64)) 相同
```

数组类型 T 不能具有类型 T 的元素，或者包含 T 作为组件的类型，直接或间接地，如果那些包含类型只


# 切片类型

切片是底层数组的连续段的描述符，提供对该数组中一系列元素的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量称为切片的长度，从不为负。未初始化的切片的值为nil。

```go
SliceType = "[" "]" ElementType .
```

切片s的长度可以通过内置函数len发现；与数组不同，它可能在执行期间改变。元素可以通过整数索引0到len(s)-1来寻址。给定元素的切片索引可能小于底层数组中相同元素的索引。

一旦初始化，切片始终与持有其元素的底层数组相关联。因此，切片与其数组以及同一数组的其他切片共享存储；相比之下，不同的数组总是代表不同的存储。

切片底层的数组可能延伸到切片的末端之外。容量是这种程度的一种衡量：它是切片长度和切片之外的数组长度的总和；最多可以通过从原始切片切片一个新的来创建该容量长度的切片。切片a的容量可以使用内置函数cap(a)发现。

可以使用内置函数make为给定元素类型T制作一个新的，初始化的切片值，该函数采用切片类型和指定长度的参数，以及可选的容量。使用make创建的切片总是分配一个新的，隐藏的数组，返回的切片值指向该数组。也就是说，执行

```go 
make([]T, length, capacity)
```

产生的切片与分配数组并将其切片相同，因此这两个表达式是等效的：

```go
make([]int, 50, 100)
new([100]int)[0:50]
```

像数组一样，切片总是一维的，但可以组合以构建更高维度的对象。对于数组的数组，内部数组在构建时总是相同的长度；但是对于切片的切片（或切片的数组），内部长度可能会动态变化。而且，必须单独初始化内部切片。